package com.example.eswproject

import android.util.Log
import kotlin.math.*

/**
 * Advanced Posture Detector with Calibration Support
 * 
 * Based on posture_corrector.py from Model folder:
 * - Supports personalized calibration (reference posture)
 * - Calculates posture score (0-100) like Python version
 * - Uses tolerance-based ranges instead of fixed thresholds
 * - Optimized for minimal latency
 */
class PostureDetector {
    
    companion object {
        private const val TAG = "PostureDetector"
        
        // COCO Keypoint indices for right side (matching YOLO model)
        private const val RIGHT_EAR = 4
        private const val RIGHT_SHOULDER = 6
        private const val RIGHT_HIP = 12
        private const val RIGHT_KNEE = 14
        private const val RIGHT_ANKLE = 16
        
        // Tolerance for acceptable posture range (from posture_corrector.py)
        private const val NECK_TOLERANCE = 8.0
        private const val BACK_TOLERANCE = 8.0
        private const val LEGS_TOLERANCE = 8.0
        
        // Angle weights for scoring (from posture_corrector.py)
        private const val NECK_WEIGHT = 1.0
        private const val BACK_WEIGHT = 1.5
        private const val LEGS_WEIGHT = 0.5
        
        // Dataset angle limits (from posture_corrector.py)
        private val ANGLE_LIMITS = mapOf(
            "neck" to Pair(125.19, 178.45),
            "back" to Pair(59.70, 145.25),
            "legs" to Pair(86.13, 164.73)
        )
    }
    
    // Ideal posture angles (can be calibrated)
    private var idealNeckAngle = 165.0  // Default from training data
    private var idealBackAngle = 175.0
    private var idealLegsAngle = 170.0
    private var maxDeviationThreshold = 0.0
    
    init {
        // Calculate max deviation threshold on initialization
        maxDeviationThreshold = computeMaxDeviationThreshold()
    }
    
    /**
     * Calibrate the detector with a reference "good" posture
     * Call this when user is in their ideal sitting position
     */
    fun calibrate(neckAngle: Double, backAngle: Double, legsAngle: Double) {
        idealNeckAngle = neckAngle
        idealBackAngle = backAngle
        idealLegsAngle = legsAngle
        maxDeviationThreshold = computeMaxDeviationThreshold()
        Log.i(TAG, "Calibrated: Neck=${"%.1f".format(neckAngle)}Â°, " +
                   "Back=${"%.1f".format(backAngle)}Â°, " +
                   "Legs=${"%.1f".format(legsAngle)}Â°")
    }
    
    /**
     * Compute max deviation threshold (from posture_corrector.py)
     */
    private fun computeMaxDeviationThreshold(): Double {
        var maxDeviation = 0.0
        
        val angles = mapOf(
            "neck" to idealNeckAngle,
            "back" to idealBackAngle,
            "legs" to idealLegsAngle
        )
        
        val weights = mapOf(
            "neck" to NECK_WEIGHT,
            "back" to BACK_WEIGHT,
            "legs" to LEGS_WEIGHT
        )
        
        for ((region, idealAngle) in angles) {
            val weight = weights[region] ?: 1.0
            val (minAngle, maxAngle) = ANGLE_LIMITS[region] ?: continue
            
            val worstAngle = if (abs(minAngle - idealAngle) > abs(maxAngle - idealAngle)) {
                minAngle
            } else {
                maxAngle
            }
            
            val worstDiff = abs(worstAngle - idealAngle)
            maxDeviation += weight * (worstDiff * worstDiff)
        }
        
        return maxDeviation
    }
    
    /**
     * Calculates the angle between three points in 2D space.
     * This is the EXACT SAME function as calculate_angle() in Python Model folder.
     * 
     * Formula: angle at point b formed by points a-b-c
     * @param a First point [x, y]
     * @param b Vertex point [x, y]
     * @param c Third point [x, y]
     * @return Angle in degrees
     */
    private fun calculateAngle(a: FloatArray, b: FloatArray, c: FloatArray): Double {
        // Vector from b to a
        val baX = a[0] - b[0]
        val baY = a[1] - b[1]
        
        // Vector from b to c
        val bcX = c[0] - b[0]
        val bcY = c[1] - b[1]
        
        // Dot product
        val dotProduct = (baX * bcX + baY * bcY).toDouble()
        
        // Magnitudes
        val magnitudeBa = sqrt((baX * baX + baY * baY).toDouble())
        val magnitudeBc = sqrt((bcX * bcX + bcY * bcY).toDouble())
        
        // Cosine of angle (with small epsilon to avoid division by zero)
        val cosineAngle = dotProduct / (magnitudeBa * magnitudeBc + 1e-6)
        
        // Clip to [-1.0, 1.0] to avoid numerical errors in acos
        val clippedCosine = cosineAngle.coerceIn(-1.0, 1.0)
        
        // Return angle in degrees
        val angleRadians = acos(clippedCosine)
        return Math.toDegrees(angleRadians)
    }
    
    /**
     * Extracts features and classifies posture from YOLO keypoints.
     * Uses EXACT SAME logic as create_dataset.py and run_live_model.py
     * 
     * @param persons List of detected persons with keypoints from YOLOv11
     * @return Posture classification result
     */
    fun analyzePosture(persons: List<PersonDetection>): PostureResult {
        if (persons.isEmpty()) {
            return PostureResult(
                posture = "NO_PERSON",
                confidence = 0.0f,
                angles = null,
                message = "No persons detected"
            )
        }
        
        // Use first detected person (same as Python: data['persons'][0])
        val person = persons[0]
        val keypoints = person.keypoints
        
        // Extract RIGHT SIDE keypoints (exact same as Python Model folder)
        val rightEar = getKeypointCoords(keypoints, RIGHT_EAR)
        val rightShoulder = getKeypointCoords(keypoints, RIGHT_SHOULDER)
        val rightHip = getKeypointCoords(keypoints, RIGHT_HIP)
        val rightKnee = getKeypointCoords(keypoints, RIGHT_KNEE)
        val rightAnkle = getKeypointCoords(keypoints, RIGHT_ANKLE)
        
        // Check if all required keypoints are present
        if (rightEar == null || rightShoulder == null || rightHip == null || 
            rightKnee == null || rightAnkle == null) {
            val missing = mutableListOf<String>()
            if (rightEar == null) missing.add("right_ear")
            if (rightShoulder == null) missing.add("right_shoulder")
            if (rightHip == null) missing.add("right_hip")
            if (rightKnee == null) missing.add("right_knee")
            if (rightAnkle == null) missing.add("right_ankle")
            
            return PostureResult(
                posture = "INCOMPLETE",
                confidence = 0.0f,
                angles = null,
                message = "Missing keypoints: ${missing.joinToString(", ")}"
            )
        }
        
        // --- CALCULATE THE THREE ANGLES (exact same as Python) ---
        
        // 1. Legs angle (Ankle-Knee-Hip)
        val legsAngle = calculateAngle(rightAnkle, rightKnee, rightHip)
        
        // 2. Back angle (Knee-Hip-Shoulder)
        val backAngle = calculateAngle(rightKnee, rightHip, rightShoulder)
        
        // 3. Neck angle (Hip-Shoulder-Ear)
        val neckAngle = calculateAngle(rightHip, rightShoulder, rightEar)
        
        val angles = PostureAngles(
            neckAngle = neckAngle,
            backAngle = backAngle,
            legsAngle = legsAngle
        )
        
        // Calculate posture score (0-100) using Python's method
        val postureScore = calculatePostureScore(neckAngle, backAngle, legsAngle)
        
        // Classify posture with tolerance-based ranges
        val classification = classifyPostureWithTolerance(neckAngle, backAngle, legsAngle, postureScore)
        
        return PostureResult(
            posture = classification.first,
            confidence = (postureScore / 100.0f).coerceIn(0f, 1f),
            score = postureScore.toInt(),
            angles = angles,
            message = classification.second,
            suggestions = classification.third
        )
    }
    
    /**
     * Calculate posture score (0-100) exactly like posture_corrector.py
     */
    private fun calculatePostureScore(neckAngle: Double, backAngle: Double, legsAngle: Double): Double {
        // Calculate squared errors
        val neckError = (neckAngle - idealNeckAngle).pow(2)
        val backError = (backAngle - idealBackAngle).pow(2)
        val legsError = (legsAngle - idealLegsAngle).pow(2)
        
        // Weighted total deviation
        val totalDeviation = (NECK_WEIGHT * neckError +
                             BACK_WEIGHT * backError +
                             LEGS_WEIGHT * legsError)
        
        // Avoid division by zero
        if (maxDeviationThreshold == 0.0) {
            return if (totalDeviation == 0.0) 100.0 else 0.0
        }
        
        // Calculate score percentage
        val scorePercentage = 1.0 - (totalDeviation / maxDeviationThreshold)
        return (scorePercentage * 100.0).coerceIn(0.0, 100.0)
    }
    
    /**
     * Classify posture using tolerance-based ranges (from posture_corrector.py)
     * Returns: Triple(posture_label, message, suggestions_list)
     */
    private fun classifyPostureWithTolerance(
        neckAngle: Double,
        backAngle: Double,
        legsAngle: Double,
        score: Double
    ): Triple<String, String, List<String>> {
        
        val suggestions = mutableListOf<String>()
        var issues = 0
        
        // Check neck angle
        val neckStatus = when {
            neckAngle < idealNeckAngle - NECK_TOLERANCE -> {
                suggestions.add("Neck: Too bent forward - tuck your chin in")
                issues++
                "BAD"
            }
            neckAngle > idealNeckAngle + NECK_TOLERANCE -> {
                suggestions.add("Neck: Too far back - bring head forward slightly")
                issues++
                "BAD"
            }
            else -> "GOOD"
        }
        
        // Check back angle
        val backStatus = when {
            backAngle < idealBackAngle - BACK_TOLERANCE -> {
                suggestions.add("Back: Slouching - sit up straight and engage core")
                issues++
                "BAD"
            }
            backAngle > idealBackAngle + BACK_TOLERANCE -> {
                suggestions.add("Back: Leaning too far back - bring torso upright")
                issues++
                "BAD"
            }
            else -> "GOOD"
        }
        
        // Check legs angle
        val legsStatus = when {
            legsAngle < idealLegsAngle - LEGS_TOLERANCE -> {
                suggestions.add("Legs: Knees too bent - adjust feet or chair height")
                issues++
                "BAD"
            }
            legsAngle > idealLegsAngle + LEGS_TOLERANCE -> {
                suggestions.add("Legs: Too extended - place feet flat on floor")
                issues++
                "BAD"
            }
            else -> "GOOD"
        }
        
        // Determine overall posture label and message
        val (label, message) = when {
            score >= 90 -> Pair("EXCELLENT", "Perfect posture! Keep it up! ðŸŽ‰")
            score >= 80 -> Pair("GOOD", "Good posture with minor room for improvement")
            issues == 0 -> Pair("STRAIGHT", "Aligned posture")
            issues == 1 -> {
                when {
                    neckStatus == "BAD" -> Pair("NECK_MISALIGNMENT", "Neck needs adjustment")
                    backStatus == "BAD" -> Pair("BACK_MISALIGNMENT", "Back needs adjustment")
                    else -> Pair("LEGS_MISALIGNMENT", "Legs need adjustment")
                }
            }
            issues == 2 -> Pair("MODERATE_MISALIGNMENT", "Multiple areas need correction")
            else -> Pair("POOR_POSTURE", "Significant posture issues detected")
        }
        
        return Triple(label, message, suggestions)
    }
    
    /**
     * Gets keypoint coordinates if confidence is sufficient.
     * Returns null if keypoint is not detected or has low confidence.
     */
    private fun getKeypointCoords(
        keypoints: List<Keypoint>,
        index: Int
    ): FloatArray? {
        if (index >= keypoints.size) return null
        val kp = keypoints[index]
        
        // Note: Confidence check commented out in Python model, so we do the same
        // But we still check if coordinates are valid
        if (kp.x == 0f && kp.y == 0f) return null
        
        return floatArrayOf(kp.x, kp.y)
    }
    
    /**
     * Data class to hold the three extracted angles
     */
    data class PostureAngles(
        val neckAngle: Double,
        val backAngle: Double,
        val legsAngle: Double
    )
    
    /**
     * Data class for posture analysis result (enhanced with score and suggestions)
     */
    data class PostureResult(
        val posture: String,
        val confidence: Float,
        val score: Int = 0,  // 0-100 posture score
        val angles: PostureAngles?,
        val message: String,
        val suggestions: List<String> = emptyList()
    )
}
        
        // Note: Confidence check commented out in Python model, so we do the same
        // But we still check if coordinates are valid
        if (kp.x == 0f && kp.y == 0f) return null
        
        return floatArrayOf(kp.x, kp.y)
    }
    
    /**
     * Classifies posture based on angle features.
     * 
     * This uses decision boundaries learned from the Random Forest model training.
     * The thresholds are derived from analyzing the posture_dataset_final.csv data.
     * 
     * Based on the trained model, typical angle ranges are:
     * 
     * STRAIGHT (good posture):
     * - knee_angle: ~165-180Â° (legs almost straight)
     * - torso_hip_angle: ~165-180Â° (upright torso)
     * - neck_torso_angle: ~155-175Â° (neck aligned with torso)
     * 
     * HUNCHBACK:
     * - neck_torso_angle: <150Â° (head forward)
     * - torso_hip_angle: often slightly reduced
     * 
     * LEANING_FORWARD:
     * - torso_hip_angle: <160Â° (torso bent forward at hip)
     * - knee_angle: may be reduced
     * 
     * LEANING_BACK:
     * - torso_hip_angle: >185Â° (torso leaning backward)
     * 
     * @return Pair of (posture_label, confidence)
     */
    private fun classifyPosture(angles: PostureAngles): Pair<String, Float> {
        val knee = angles.kneeAngle
        val torsoHip = angles.torsoHipAngle
        val neckTorso = angles.neckTorsoAngle
        
        // Decision tree logic mimicking the Random Forest model
        
        // Check for STRAIGHT posture (good posture)
        if (neckTorso >= 155 && neckTorso <= 180 &&
            torsoHip >= 165 && torsoHip <= 185 &&
            knee >= 160) {
            return Pair("STRAIGHT", 0.95f)
        }
        
        // Check for HUNCHBACK (head forward, neck angle low)
        if (neckTorso < 150) {
            // Strong hunchback indicator
            return Pair("HUNCHBACK", 0.90f)
        }
        
        // Check for LEANING_FORWARD (torso bent forward)
        if (torsoHip < 160) {
            return Pair("LEANING_FORWARD", 0.85f)
        }
        
        // Check for LEANING_BACK (torso bent backward)
        if (torsoHip > 185) {
            return Pair("LEANING_BACK", 0.85f)
        }
        
        // Edge cases: slight variations of straight posture
        if (neckTorso >= 150 && torsoHip >= 160 && torsoHip <= 185) {
            return Pair("STRAIGHT", 0.70f)
        }
        
        // Default: closest match based on most deviant angle
        val neckDeviation = abs(neckTorso - 165)
        val torsoDeviation = abs(torsoHip - 175)
        
        return when {
            neckDeviation > torsoDeviation -> {
                if (neckTorso < 165) Pair("HUNCHBACK", 0.65f)
                else Pair("STRAIGHT", 0.60f)
            }
            torsoDeviation > 10 -> {
                if (torsoHip < 175) Pair("LEANING_FORWARD", 0.65f)
                else Pair("LEANING_BACK", 0.65f)
            }
            else -> Pair("STRAIGHT", 0.55f)
        }
    }
    
    /**
     * Gets user-friendly message for detected posture
     */
    private fun getPostureMessage(posture: String): String {
        return when (posture) {
            "STRAIGHT" -> "Good posture! Keep it up!"
            "HUNCHBACK" -> "Hunchback detected. Straighten your neck and shoulders."
            "LEANING_FORWARD" -> "Leaning forward detected. Sit upright."
            "LEANING_BACK" -> "Leaning back detected. Sit upright."
            "NO_PERSON" -> "No person detected in frame"
            "INCOMPLETE" -> "Cannot analyze posture - some body parts not visible"
            else -> "Unknown posture"
        }
    }
    
    /**
     * Data class to hold the three extracted angles
     */
    data class PostureAngles(
        val kneeAngle: Double,
        val torsoHipAngle: Double,
        val neckTorsoAngle: Double
    )
    
    /**
     * Data class for posture analysis result
     */
    data class PostureResult(
        val posture: String,
        val confidence: Float,
        val angles: PostureAngles?,
        val message: String
    )
}
