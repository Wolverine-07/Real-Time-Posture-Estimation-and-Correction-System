package com.example.eswproject

import android.graphics.Rect
import android.media.Image
import androidx.camera.core.ImageAnalysis
import androidx.camera.core.ImageProxy
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.pose.PoseDetection
import com.google.mlkit.vision.pose.PoseDetector
import com.google.mlkit.vision.pose.accurate.AccuratePoseDetectorOptions
import com.google.mlkit.vision.pose.PoseLandmark
import kotlin.math.max
import kotlin.math.min

class PoseAnalyzer(
    private val onPersonsDetected: (List<PersonDetection>) -> Unit
) : ImageAnalysis.Analyzer {

    private val detector: PoseDetector by lazy {
        PoseDetection.getClient(
            AccuratePoseDetectorOptions.Builder()
                .setDetectorMode(AccuratePoseDetectorOptions.STREAM_MODE)
                .build()
        )
    }

    @Volatile private var processing = false

    override fun analyze(image: ImageProxy) {
        try {
            if (processing) { image.close(); return }
            processing = true
            val mediaImage: Image = image.image ?: run { processing = false; image.close(); return }
            val rotation = image.imageInfo.rotationDegrees
            val input = InputImage.fromMediaImage(mediaImage, rotation)
            detector.process(input)
                .addOnSuccessListener { pose ->
                    val landmarks = pose.allPoseLandmarks
                    if (landmarks.isEmpty()) {
                        onPersonsDetected(emptyList())
                    } else {
                        // ML Kit returns coordinates in the InputImage coordinate system
                        // which accounts for rotation. Get the rotated dimensions.
                        val (displayWidth, displayHeight) = when (rotation) {
                            90, 270 -> mediaImage.height to mediaImage.width
                            else -> mediaImage.width to mediaImage.height
                        }
                        
                        val keypoints = landmarks.mapNotNull { lm ->
                            val type = landmarkToKeypointType(lm.landmarkType)
                            if (type != null) Keypoint(lm.position.x, lm.position.y, lm.inFrameLikelihood, type) else null
                        }
                        val bbox = computeBoundingBox(landmarks)
                        val person = PersonDetection(
                            boundingBox = BoundingBox(bbox.left.toFloat(), bbox.top.toFloat(), bbox.right.toFloat(), bbox.bottom.toFloat()),
                            confidence = 1f,
                            keypoints = keypoints,
                            imageWidth = displayWidth,
                            imageHeight = displayHeight
                        )
                        onPersonsDetected(listOf(person))
                    }
                }
                .addOnFailureListener { onPersonsDetected(emptyList()) }
                .addOnCompleteListener { processing = false; image.close() }
        } catch (t: Throwable) {
            t.printStackTrace()
            processing = false
            image.close()
            onPersonsDetected(emptyList())
        }
    }

    private fun landmarkToKeypointType(id: Int): KeypointType? = when (id) {
        PoseLandmark.NOSE -> KeypointType.NOSE
        PoseLandmark.LEFT_EYE_INNER, PoseLandmark.LEFT_EYE -> KeypointType.LEFT_EYE
        PoseLandmark.RIGHT_EYE_INNER, PoseLandmark.RIGHT_EYE -> KeypointType.RIGHT_EYE
        PoseLandmark.LEFT_EAR -> KeypointType.LEFT_EAR
        PoseLandmark.RIGHT_EAR -> KeypointType.RIGHT_EAR
        PoseLandmark.LEFT_SHOULDER -> KeypointType.LEFT_SHOULDER
        PoseLandmark.RIGHT_SHOULDER -> KeypointType.RIGHT_SHOULDER
        PoseLandmark.LEFT_ELBOW -> KeypointType.LEFT_ELBOW
        PoseLandmark.RIGHT_ELBOW -> KeypointType.RIGHT_ELBOW
        PoseLandmark.LEFT_WRIST -> KeypointType.LEFT_WRIST
        PoseLandmark.RIGHT_WRIST -> KeypointType.RIGHT_WRIST
        PoseLandmark.LEFT_HIP -> KeypointType.LEFT_HIP
        PoseLandmark.RIGHT_HIP -> KeypointType.RIGHT_HIP
        PoseLandmark.LEFT_KNEE -> KeypointType.LEFT_KNEE
        PoseLandmark.RIGHT_KNEE -> KeypointType.RIGHT_KNEE
        PoseLandmark.LEFT_ANKLE -> KeypointType.LEFT_ANKLE
        PoseLandmark.RIGHT_ANKLE -> KeypointType.RIGHT_ANKLE
        else -> null
    }

    private fun computeBoundingBox(landmarks: List<PoseLandmark>): Rect {
        var minX = Float.MAX_VALUE; var minY = Float.MAX_VALUE
        var maxX = -Float.MAX_VALUE; var maxY = -Float.MAX_VALUE
        landmarks.forEach { lm ->
            minX = min(minX, lm.position.x); minY = min(minY, lm.position.y)
            maxX = max(maxX, lm.position.x); maxY = max(maxY, lm.position.y)
        }
        return Rect(minX.toInt(), minY.toInt(), maxX.toInt(), maxY.toInt())
    }
}
